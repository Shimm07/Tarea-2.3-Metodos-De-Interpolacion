# -*- coding: utf-8 -*-
"""Untitled15.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eGUllXfbuAFCWp1-_vvxAizVPraQbP7C
"""

#   Codigo que implementa el esquema numerico
#   de interpolacion para determinar la raiz de
#   una ecuacion
#
#           Autor:
#   Dr. Ivan de Jesus May-Cen
#   imaycen@hotmail.com
#   Version 1.0 : 11/02/2025
#
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Función original f(x)
def f(x):
    return x**3 - 6*x**2 + 11*x - 6

# Función para la interpolación de Lagrange
def lagrange_interpolation(x, x_points, y_points):
    n = len(x_points)
    result = 0
    for i in range(n):
        term = y_points[i]
        for j in range(n):
            if i != j:
                term *= (x - x_points[j]) / (x_points[i] - x_points[j])
        result += term
    return result

# Método de Bisección con cálculo de errores
def bisect(func, a, b, tol=1e-6, max_iter=20):
    if func(a) * func(b) > 0:
        raise ValueError("El intervalo no contiene una raíz")

    iter_data = []  # Lista para almacenar datos de iteraciones
    root = (a + b) / 2  # Valor inicial de la raíz
    for i in range(max_iter):
        root_prev = root  # Almacena el valor previo de la raíz
        root = (a + b) / 2  # Punto medio del intervalo
        f_root = func(root)

        # Cálculo de errores
        error_abs = abs(root - root_prev)
        error_rel = abs(error_abs / root) if root != 0 else 0
        error_cuad = error_abs ** 2

        iter_data.append([i + 1, root, f_root, error_abs, error_rel, error_cuad])

        # Actualización del intervalo según el signo de la función
        if func(a) * f_root < 0:
            b = root
        else:
            a = root

    return root, iter_data  # Retorna la raíz y los datos de iteración

# Selección de tres puntos de interpolación dentro del intervalo [1,3]
x0, x1, x2 = 1.0, 2.0, 3.0
x_points = np.array([x0, x1, x2])
y_points = f(x_points)

# Construcción del polinomio interpolante
x_vals = np.linspace(x0, x2, 100)
y_interp = [lagrange_interpolation(x, x_points, y_points) for x in x_vals]

# Encontrar raíz del polinomio interpolante usando bisección
target_func = lambda x: lagrange_interpolation(x, x_points, y_points)
root, iter_data = bisect(target_func, x0, x2, max_iter=20)  # Asegurar 20 iteraciones

# Mostrar tabla de iteraciones
df = pd.DataFrame(iter_data, columns=["Iteración", "Raíz", "f(Raíz)", "Error Absoluto", "Error Relativo", "Error Cuadrático"])
print(df.to_string(index=False))

# Gráficas
plt.figure(figsize=(10, 6))
plt.plot(x_vals, f(x_vals), label="f(x) = x^3 - 6x^2 + 11x - 6", linestyle='dashed', color='blue')
plt.plot(x_vals, y_interp, label="Interpolación de Lagrange", color='red')
plt.axhline(0, color='black', linewidth=0.5, linestyle='--')
plt.axvline(root, color='green', linestyle='dotted', label=f"Raíz aprox: {root:.4f}")
plt.scatter(x_points, y_points, color='black', label="Puntos de interpolación")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.title("Interpolación de Lagrange y Raíces")
plt.legend()
plt.grid(True)
plt.savefig("interpolacion_raices.png")
plt.show()

# Gráfica de convergencia de errores
errors = np.array(iter_data)[:, [3, 4, 5]]  # Extraer columnas de errores
plt.figure(figsize=(10, 5))
plt.plot(range(1, len(errors) + 1), errors[:, 0], marker='o', label="Error Absoluto")
plt.plot(range(1, len(errors) + 1), errors[:, 1], marker='s', label="Error Relativo")
plt.plot(range(1, len(errors) + 1), errors[:, 2], marker='^', label="Error Cuadrático")
plt.xlabel("Iteración")
plt.ylabel("Error")
plt.title("Convergencia del Método de Bisección")
plt.legend()
plt.grid(True)
plt.savefig("convergencia_errores.png")
plt.show()

# Análisis de convergencia
print("\nAnálisis de Convergencia:")
print(f"La raíz aproximada encontrada es {root:.6f} después de {len(iter_data)} iteraciones.")
print("El método muestra una convergencia estable con reducción progresiva de los errores.")